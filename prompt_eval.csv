idx,question,answer,best_GPT4code,result
1,"If we list all the natural numbers below $10$ that are multiples of $3$ or $5$, we get $3, 5, 6$ and $9$. The sum of these multiples is $23$.
Find the sum of all the multiples of $3$ or $5$ below $1000$.
",233168,"# Python code to calculate the sum of multiples of 3 or 5 below 1000
sum_of_multiples = sum(x for x in range(1000) if x % 3 == 0 or x % 5 == 0)
print(sum_of_multiples)",233168
2,"Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with $1$ and $2$, the first $10$ terms will be:
$$1, 2, 3, 5, 8, 13, 21, 34, 55, 89, \dots$$
By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

",4613732,"# Python code to find the sum of even-valued terms in the Fibonacci sequence not exceeding four million
a, b = 1, 2
total = 0
while b <= 4000000:
    if b % 2 == 0:
        total += b
    a, b = b, a + b
print(total)",4613732
3,"The prime factors of $13195$ are $5, 7, 13$ and $29$.
What is the largest prime factor of the number $600851475143$?


",6857,"# Python code to find the largest prime factor
def largest_prime_factor(n):
    i = 2
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
    return n

# The largest prime factor of the number 600851475143
print(largest_prime_factor(600851475143))",6857
4,"A palindromic number reads the same both ways. The largest palindrome made from the product of two $2$-digit numbers is $9009 = 91 \times 99$.
Find the largest palindrome made from the product of two $3$-digit numbers.

",906609,"def is_palindrome(num):
    return str(num) == str(num)[::-1]

max_palindrome = 0
for i in range(100, 1000):
    for j in range(100, 1000):
        product = i * j
        if is_palindrome(product) and product > max_palindrome:
            max_palindrome = product

print(max_palindrome)",906609
5,"$2520$ is the smallest number that can be divided by each of the numbers from $1$ to $10$ without any remainder.
What is the smallest positive number that is evenly divisibledivisible with no remainder by all of the numbers from $1$ to $20$?

",232792560,"def smallest_multiple(n):
    if n <= 2:
        return n
    multiple = n
    while True:
        for i in range(n, 1, -1):
            if multiple % i != 0:
                break
        else:
            return multiple
        multiple += n

# Smallest multiple for numbers 1 to 20
print(smallest_multiple(20))",232792560
6,"The sum of the squares of the first ten natural numbers is,
$$1^2 + 2^2 + ... + 10^2 = 385.$$
The square of the sum of the first ten natural numbers is,
$$(1 + 2 + ... + 10)^2 = 55^2 = 3025.$$
Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is $3025 - 385 = 2640$.
Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
",25164150,"# Python code to calculate the difference between the sum of the squares and the square of the sum of the first one hundred natural numbers

# Function to calculate the sum of squares
def sum_of_squares(n):
    return sum(i**2 for i in range(1, n+1))

# Function to calculate the square of the sum
def square_of_sum(n):
    return sum(range(1, n+1)) ** 2

# Calculate the difference
difference = square_of_sum(100) - sum_of_squares(100)
difference",
7,"By listing the first six prime numbers: $2, 3, 5, 7, 11$, and $13$, we can see that the $6$th prime is $13$.
What is the $10\,001$st prime number?

",104743,"def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def find_nth_prime(n):
    count = 0
    prime = 2
    while count < n:
        if is_prime(prime):
            count += 1
        if count < n:
            prime += 1
    return prime

# Find the 10001st prime number
nth_prime = find_nth_prime(10001)
print(nth_prime)",104743
9,"A Pythagorean triplet is a set of three natural numbers, $a \lt b \lt c$, for which,
$$a^2 + b^2 = c^2.$$
For example, $3^2 + 4^2 = 9 + 16 = 25 = 5^2$.
There exists exactly one Pythagorean triplet for which $a + b + c = 1000$.Find the product $abc$.

",31875000,"for a in range(1, 1000):
    for b in range(a, 1000 - a):
        c = 1000 - a - b
        if a * a + b * b == c * c:
            print(a * b * c)
            break",31875000
10,"The sum of the primes below $10$ is $2 + 3 + 5 + 7 = 17$.
Find the sum of all the primes below two million.



",142913828922,"# Sieve of Eratosthenes algorithm to find all primes below n
def sieve(n):
    prime = [True for _ in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return [p for p in range(2, n) if prime[p]]

# Sum of all primes below two million
print(sum(sieve(2000000)))",142914000000
15,"Starting in the top left corner of a $2 \times 2$ grid, and only being able to move to the right and down, there are exactly $6$ routes to the bottom right corner.


How many such routes are there through a $20 \times 20$ grid?

",137846528820,"import math

# Function to calculate number of routes in a grid
def calculate_routes(n, k):
    return math.comb(n + k, n)

# Grid size
grid_size = 20

# Calculate the number of routes for a 20x20 grid
routes = calculate_routes(grid_size, grid_size)
print(routes)",137847000000
16,"$2^{15} = 32768$ and the sum of its digits is $3 + 2 + 7 + 6 + 8 = 26$.
What is the sum of the digits of the number $2^{1000}$?

",1366,"# Python code to calculate the sum of the digits of the number 2^1000
print(sum(int(digit) for digit in str(2**1000)))",1366
19,"
You are given the following information, but you may prefer to do some research for yourself.
1 Jan 1900 was a Monday.
Thirty days has September,
April, June and November.
All the rest have thirty-one,
Saving February alone,
Which has twenty-eight, rain or shine.
And on leap years, twenty-nine.
A leap year occurs on any year evenly divisible by 4, but not on a century unless it is divisible by 400.
How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?

",171,"import datetime

def count_sundays_on_first_of_month(start_year, end_year):
    # Count of Sundays that fell on the first of the month
    sunday_count = 0
    
    # Loop over each month of each year
    for year in range(start_year, end_year + 1):
        for month in range(1, 13):
            # If the first day of the month is a Sunday
            if datetime.date(year, month, 1).weekday() == 6:
                sunday_count += 1
                
    return sunday_count

# Count the number of Sundays that fell on the first of the month during the 20th century
print(count_sundays_on_first_of_month(1901, 2000))",171
20,"$n!$ means $n \times (n - 1) \times \cdots \times 3 \times 2 \times 1$.
For example, $10! = 10 \times 9 \times \cdots \times 3 \times 2 \times 1 = 3628800$,and the sum of the digits in the number $10!$ is $3 + 6 + 2 + 8 + 8 + 0 + 0 = 27$.
Find the sum of the digits in the number $100!$.

",648,"import math

def sum_of_digits(n):
    return sum(int(digit) for digit in str(math.factorial(n)))

# Find the sum of the digits in the number 100!
print(sum_of_digits(100))",648
24,"A permutation is an ordered arrangement of objects. For example, 3124 is one possible permutation of the digits 1, 2, 3 and 4. If all of the permutations are listed numerically or alphabetically, we call it lexicographic order. The lexicographic permutations of 0, 1 and 2 are:
012   021   102   120   201   210
What is the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9?

",2783915460,"from itertools import permutations

# Get all lexicographic permutations of the digits
perms = list(permutations('0123456789'))

# Convert each tuple to a string
perms = [''.join(p) for p in perms]

# The millionth lexicographic permutation
millionth_permutation = perms[999999]
print(millionth_permutation)",2783915460
28,"Starting with the number $1$ and moving to the right in a clockwise direction a $5$ by $5$ spiral is formed as follows:
21 22 23 24 25
20  7  8  9 10
19  6  1  2 11
18  5  4  3 1217 16 15 14 13
It can be verified that the sum of the numbers on the diagonals is $101$.
What is the sum of the numbers on the diagonals in a $1001$ by $1001$ spiral formed in the same way?

",669171001,"def diagonal_sum(n):
    sum = 1
    for i in range(3, n+1, 2):
        sum += 4*i**2 - 6*(i-1)
    return sum

# Size of the grid
grid_size = 1001
print(diagonal_sum(grid_size))",669171001
31,"In the United Kingdom the currency is made up of pound (£) and pence (p). There are eight coins in general circulation:
1p, 2p, 5p, 10p, 20p, 50p, £1 (100p), and £2 (200p).
It is possible to make £2 in the following way:
1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p
How many different ways can £2 be made using any number of coins?

",73682,"def count_ways(coins, n, target):
    ways = [0] * (target + 1)
    ways[0] = 1
    for i in range(n):
        for j in range(coins[i], target + 1):
            ways[j] += ways[j - coins[i]]
    return ways[target]

coins = [1, 2, 5, 10, 20, 50, 100, 200]
n = len(coins)
target = 200
print(count_ways(coins, n, target))",73682
34,"$145$ is a curious number, as $1! + 4! + 5! = 1 + 24 + 120 = 145$.
Find the sum of all numbers which are equal to the sum of the factorial of their digits.
Note: As $1! = 1$ and $2! = 2$ are not sums they are not included.

",40730,"from math import factorial

# Function to calculate the sum of factorials of the digits of a number
def sum_of_digit_factorials(n):
    return sum(factorial(int(digit)) for digit in str(n))

# Find all numbers which are equal to the sum of the factorial of their digits
def find_curious_numbers(limit):
    curious_numbers = []
    for i in range(10, limit):  # Starting from 10 because 1! and 2! are not sums
        if i == sum_of_digit_factorials(i):
            curious_numbers.append(i)
    return curious_numbers

# Calculate the upper limit for search (9! * 7 is a reasonable limit because 9! * 8 has more digits)
upper_limit = factorial(9) * 7

# Find curious numbers and calculate their sum
curious_numbers = find_curious_numbers(upper_limit)
sum_curious_numbers = sum(curious_numbers)
print(sum_curious_numbers)",40730
35,"The number, $197$, is called a circular prime because all rotations of the digits: $197$, $971$, and $719$, are themselves prime.
There are thirteen such primes below $100$: $2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79$, and $97$.
How many circular primes are there below one million?

",55,"from sympy import isprime

def rotate_number(n):
    return [int(str(n)[i:] + str(n)[:i]) for i in range(len(str(n)))]

def is_circular_prime(n):
    return all(isprime(num) for num in rotate_number(n))

circular_primes = [n for n in range(2, 1000000) if is_circular_prime(n)]
print(len(circular_primes))",55
36,"The decimal number, $585 = 1001001001_2$ (binary), is palindromic in both bases.
Find the sum of all numbers, less than one million, which are palindromic in base $10$ and base $2$.
(Please note that the palindromic number, in either base, may not include leading zeros.)

",872187,"# Python code to solve the problem

def is_palindrome(num):
    return str(num) == str(num)[::-1]

def sum_palindromic_numbers(limit):
    total_sum = 0
    for num in range(limit):
        if is_palindrome(num) and is_palindrome(bin(num)[2:]):
            total_sum += num
    return total_sum

# Find the sum of all numbers less than one million
# which are palindromic in base 10 and base 2
print(sum_palindromic_numbers(1000000))",872187
37,"The number $3797$ has an interesting property. Being prime itself, it is possible to continuously remove digits from left to right, and remain prime at each stage: $3797$, $797$, $97$, and $7$. Similarly we can work from right to left: $3797$, $379$, $37$, and $3$.
Find the sum of the only eleven primes that are both truncatable from left to right and right to left.
NOTE: $2$, $3$, $5$, and $7$ are not considered to be truncatable primes.

",748317,"def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def is_truncatable_prime(n):
    if n < 10:
        return False
    str_n = str(n)
    for i in range(len(str_n)):
        if not is_prime(int(str_n[i:])) or not is_prime(int(str_n[:i+1])):
            return False
    return True

truncatable_primes = []
n = 11
while len(truncatable_primes) < 11:
    if is_truncatable_prime(n):
        truncatable_primes.append(n)
    n += 2

sum_of_truncatable_primes = sum(truncatable_primes)
print(sum_of_truncatable_primes)",748317
39,"If $p$ is the perimeter of a right angle triangle with integral length sides, $\{a, b, c\}$, there are exactly three solutions for $p = 120$.
$\{20,48,52\}$, $\{24,45,51\}$, $\{30,40,50\}$
For which value of $p \le 1000$, is the number of solutions maximised?

",840,"def count_solutions(p):
    count = 0
    for a in range(1, p//3):
        for b in range(a, (p-a)//2):
            c = p - a - b
            if a*a + b*b == c*c:
                count += 1
    return count

max_solutions = 0
p_with_max_solutions = 0

for p in range(12, 1001):  # 12 is the smallest perimeter of a right triangle with integral length sides
    solutions = count_solutions(p)
    if solutions > max_solutions:
        max_solutions = solutions
        p_with_max_solutions = p

print(p_with_max_solutions)",840
41,"We shall say that an $n$-digit number is pandigital if it makes use of all the digits $1$ to $n$ exactly once. For example, $2143$ is a $4$-digit pandigital and is also prime.
What is the largest $n$-digit pandigital prime that exists?

",7652413,"from itertools import permutations
from sympy import isprime

def largest_pandigital_prime():
    # Start with the largest n-digit pandigital number and go down
    for n in range(9, 0, -1):
        pandigitals = permutations('123456789'[:n])
        for p in sorted(pandigitals, reverse=True):
            num = int(''.join(p))
            if isprime(num):
                return num
    return None

# Call the function and print the result
print(largest_pandigital_prime())",7652413
48,"The series, $1^1 + 2^2 + 3^3 + \cdots + 10^{10} = 10405071317$.
Find the last ten digits of the series, $1^1 + 2^2 + 3^3 + \cdots + 1000^{1000}$.

",9110846700,"# Python code to find the last ten digits of the series 1^1 + 2^2 + 3^3 + ... + 1000^1000

# Initialize the sum
series_sum = 0

# Calculate the sum of the series
for i in range(1, 1001):
    series_sum += i**i

# Get the last ten digits
last_ten_digits = str(series_sum)[-10:]

print(last_ten_digits)",9110846700
50,"The prime $41$, can be written as the sum of six consecutive primes:
$$41 = 2 + 3 + 5 + 7 + 11 + 13.$$
This is the longest sum of consecutive primes that adds to a prime below one-hundred.
The longest sum of consecutive primes below one-thousand that adds to a prime, contains $21$ terms, and is equal to $953$.
Which prime, below one-million, can be written as the sum of the most consecutive primes?
",997651,"def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def find_longest_prime_sum(limit):
    primes = [2]
    sum_of_primes = 2
    max_length = 1
    max_prime = 2
    # Generate primes using Sieve of Eratosthenes
    sieve = [True] * limit
    for p in range(3, limit, 2):
        if sieve[p]:
            primes.append(p)
            sum_of_primes += p
            if sum_of_primes < limit and is_prime(sum_of_primes):
                max_length = len(primes)
                max_prime = sum_of_primes
            for i in range(p*p, limit, 2*p):
                sieve[i] = False
    # Find the longest sum of consecutive primes
    for i in range(len(primes)):
        for j in range(i + max_length, len(primes)):
            sum_of_primes = sum(primes[i:j])
            if sum_of_primes >= limit:
                break
            if j - i > max_length and is_prime(sum_of_primes):
                max_length = j - i
                max_prime = sum_of_primes
    return max_prime

# Change the limit to 1,000,000 as per the problem statement
print(find_longest_prime_sum(1000000))",997651
52,"It can be seen that the number, $125874$, and its double, $251748$, contain exactly the same digits, but in a different order.
Find the smallest positive integer, $x$, such that $2x$, $3x$, $4x$, $5x$, and $6x$, contain the same digits.

",142857,"def same_digits(x):
    return sorted(str(x)) == sorted(str(2*x)) == sorted(str(3*x)) == sorted(str(4*x)) == sorted(str(5*x)) == sorted(str(6*x))

x = 1
while not same_digits(x):
    x += 1
print(x)",142857
56,"A googol ($10^{100}$) is a massive number: one followed by one-hundred zeros; $100^{100}$ is almost unimaginably large: one followed by two-hundred zeros. Despite their size, the sum of the digits in each number is only $1$.
Considering natural numbers of the form, $a^b$, where $a, b \lt 100$, what is the maximum digital sum?

",972,"# Python code to find the maximum digital sum of a^b for 0 < a, b < 100

def digital_sum(n):
    return sum(int(digit) for digit in str(n))

max_sum = 0
for a in range(1, 100):
    for b in range(1, 100):
        max_sum = max(max_sum, digital_sum(a**b))

print(max_sum)",972
60,"The primes $3$, $7$, $109$, and $673$, are quite remarkable. By taking any two primes and concatenating them in any order the result will always be prime. For example, taking $7$ and $109$, both $7109$ and $1097$ are prime. The sum of these four primes, $792$, represents the lowest sum for a set of four primes with this property.
Find the lowest sum for a set of five primes for which any two primes concatenate to produce another prime.

",26033,"from sympy import isprime
from itertools import permutations

def check_prime_pair_set(prime_set):
    return all(isprime(int(str(p[0]) + str(p[1]))) and isprime(int(str(p[1]) + str(p[0]))) for p in permutations(prime_set, 2))

primes = [3, 7, 11, 17, 19, 23, 29, 31]  # Starting list of primes
sets = []

for i in primes:
    for j in primes:
        if j > i:
            if check_prime_pair_set({i, j}):
                for k in primes:
                    if k > j:
                        if check_prime_pair_set({i, j, k}):
                            for l in primes:
                                if l > k:
                                    if check_prime_pair_set({i, j, k, l}):
                                        for m in primes:
                                            if m > l:
                                                if check_prime_pair_set({i, j, k, l, m}):
                                                    sets.append((i, j, k, l, m))

# Find the set with the lowest sum
lowest_sum = float('inf')
lowest_set = ()
for s in sets:
    if sum(s) < lowest_sum:
        lowest_sum = sum(s)
        lowest_set = s

print(lowest_set, lowest_sum)",() inf
62,"The cube, $41063625$ ($345^3$), can be permuted to produce two other cubes: $56623104$ ($384^3$) and $66430125$ ($405^3$). In fact, $41063625$ is the smallest cube which has exactly three permutations of its digits which are also cube.
Find the smallest cube for which exactly five permutations of its digits are cube.

",127035954683,"from collections import defaultdict

def find_smallest_cube(permutations):
    cubes = defaultdict(list)
    n = 345
    while True:
        cube = n**3
        key = ''.join(sorted(str(cube)))
        cubes[key].append(cube)
        if len(cubes[key]) == permutations:
            return min(cubes[key])
        n += 1

# Find the smallest cube for which exactly five permutations of its digits are cube
smallest_cube = find_smallest_cube(5)
print(smallest_cube)",127036000000
63,"The $5$-digit number, $16807=7^5$, is also a fifth power. Similarly, the $9$-digit number, $134217728=8^9$, is a ninth power.
How many $n$-digit positive integers exist which are also an $n$th power?

",49,"# Python code to find the count of n-digit positive integers which are also an nth power

count = 0
for n in range(1, 22):  # 22 is the upper limit since 9**22 is the largest 21-digit number
    for base in range(1, 10):  # Single digit base (1-9)
        if len(str(base**n)) == n:
            count += 1
print(count)",49
76,"It is possible to write five as a sum in exactly six different ways:
\begin{align}
&amp;4 + 1\\
&amp;3 + 2\\
&amp;3 + 1 + 1\\
&amp;2 + 2 + 1\\
&amp;2 + 1 + 1 + 1\\
&amp;1 + 1 + 1 + 1 + 1
\end{align}
How many different ways can one hundred be written as a sum of at least two positive integers?

",190569291,"def count_ways(n):
    ways = [0] * (n + 1)
    ways[0] = 1
    for i in range(1, n):
        for j in range(i, n + 1):
            ways[j] += ways[j - i]
    return ways[n]

# Call the function with the target sum
print(count_ways(100))",190569291
77,"It is possible to write ten as the sum of primes in exactly five different ways:
\begin{align}
&amp;7 + 3\\
&amp;5 + 5\\
&amp;5 + 3 + 2\\
&amp;3 + 3 + 2 + 2\\
&amp;2 + 2 + 2 + 2 + 2
\end{align}
What is the first value which can be written as the sum of primes in over five thousand different ways?

",71,"def prime_sums(limit):
    primes = [2]
    for i in range(3, limit, 2):
        if all(i % p != 0 for p in primes):
            primes.append(i)

    ways = [0] * (limit + 1)
    ways[0] = 1

    for prime in primes:
        for i in range(prime, limit + 1):
            ways[i] += ways[i - prime]

    for i in range(limit + 1):
        if ways[i] > 5000:
            return i

print(prime_sums(100))  # Adjust the limit as needed to find the solution.",71
79,"A common security method used for online banking is to ask the user for three random characters from a passcode. For example, if the passcode was 531278, they may ask for the 2nd, 3rd, and 5th characters; the expected reply would be: 317.
The text file, keylog.txt, contains fifty successful login attempts.
Given that the three characters are always asked for in order, analyse the file so as to determine the shortest possible secret passcode of unknown length.

",73162890,"from collections import defaultdict

# Function to read the file and return the contents
def read_file(filename):
    with open(filename, 'r') as file:
        return file.read().splitlines()

# Function to deduce the passcode
def deduce_passcode(attempts):
    # Create a dictionary to hold the order of digits
    order = defaultdict(set)
    for attempt in attempts:
        order[attempt[0]].update(attempt[1:])
        order[attempt[1]].add(attempt[2])

    # Create a list to hold the sorted passcode
    passcode = []
    while order:
        # Find the digit that precedes no other digits
        for digit, after in order.items():
            if not any(digit in after_set for after_set in order.values() if after_set != after):
                passcode.append(digit)
                # Remove the digit from the order dictionary
                order.pop(digit)
                # Remove the digit from all other sets
                for after_set in order.values():
                    after_set.discard(digit)
                break

    return ''.join(passcode)

# Main execution
if __name__ == ""__main__"":
    login_attempts = read_file('keylog.txt')
    print(deduce_passcode(login_attempts))",
80,"It is well known that if the square root of a natural number is not an integer, then it is irrational. The decimal expansion of such square roots is infinite without any repeating pattern at all.
The square root of two is $1.41421356237309504880\cdots$, and the digital sum of the first one hundred decimal digits is $475$.
For the first one hundred natural numbers, find the total of the digital sums of the first one hundred decimal digits for all the irrational square roots.

",40886,"import math
from decimal import Decimal, getcontext

# Set precision for Decimal operations
getcontext().prec = 102

def digital_sum(n):
    # Find the square root of n with Decimal precision
    root = Decimal(n).sqrt()
    # Convert to string, remove the decimal point, take the first 100 digits
    digits = str(root).replace('.', '')[:100]
    # Calculate the sum of these digits
    return sum(int(digit) for digit in digits)

# Calculate the total digital sum for the first 100 natural numbers
total_sum = sum(digital_sum(i) for i in range(1, 101) if not math.isqrt(i)**2 == i)

print(total_sum)",40886
85,"By counting carefully it can be seen that a rectangular grid measuring $3$ by $2$ contains eighteen rectangles:


Although there exists no rectangular grid that contains exactly two million rectangles, find the area of the grid with the nearest solution.

",2772,"def count_rectangles(w, h):
    return (w * (w + 1) * h * (h + 1)) // 4

def find_nearest_area(target):
    min_diff = float('inf')
    nearest_area = 0
    for w in range(1, 100):
        for h in range(1, 100):
            rect_count = count_rectangles(w, h)
            diff = abs(rect_count - target)
            if diff < min_diff:
                min_diff = diff
                nearest_area = w * h
    return nearest_area

# Find the area of the grid with the nearest solution to two million rectangles
area = find_nearest_area(2000000)
print(area)",2772
94,"It is easily proved that no equilateral triangle exists with integral length sides and integral area. However, the almost equilateral triangle $5$-$5$-$6$ has an area of $12$ square units.
We shall define an almost equilateral triangle to be a triangle for which two sides are equal and the third differs by no more than one unit.
Find the sum of the perimeters of all almost equilateral triangles with integral side lengths and area and whose perimeters do not exceed one billion ($1\,000\,000\,000$).

",518408346,"def heron(a, b, c):
    s = (a + b + c) / 2
    return (s*(s-a)*(s-b)*(s-c))**0.5

def check_integral_area(a, b, c):
    area = heron(a, b, c)
    return area.is_integer()

perimeter_sum = 0
limit = 1000000000

for side in range(2, limit//3 + 1):
    for diff in [-1, 1]:
        a = side
        b = side
        c = side + diff
        if check_integral_area(a, b, c):
            perimeter = a + b + c
            if perimeter < limit:
                perimeter_sum += perimeter

print(perimeter_sum)",
114,"A row measuring seven units in length has red blocks with a minimum length of three units placed on it, such that any two red blocks (which are allowed to be different lengths) are separated by at least one grey square. There are exactly seventeen ways of doing this.





How many ways can a row measuring fifty units in length be filled?
NOTE: Although the example above does not lend itself to the possibility, in general it is permitted to mix block sizes. For example, on a row measuring eight units in length you could use red (3), grey (1), and red (4).
",16475640049,"def count_ways(length):
    # Memoization array
    ways = [0] * (length + 1)
    ways[0] = 1  # Base case

    for n in range(3, length + 1):
        ways[n] += ways[n - 1]  # Add grey block
        ways[n] += ways[n - 3]  # Add red block of size 3
        for m in range(4, n + 1):  # Add red blocks of size 4 to n
            ways[n] += ways[n - m]

    return ways[length]

# Length of the row
row_length = 50
print(count_ways(row_length))",288627000000
117,"Using a combination of grey square tiles and oblong tiles chosen from: red tiles (measuring two units), green tiles (measuring three units), and blue tiles (measuring four units), it is possible to tile a row measuring five units in length in exactly fifteen different ways.





How many ways can a row measuring fifty units in length be tiled?
NOTE: This is related to Problem 116.
",100808458960497,"def count_ways(length, tile_sizes):
    ways = [1] * (length + 1)
    for size in tile_sizes:
        for i in range(size, length + 1):
            ways[i] += ways[i - size]
    return ways[length] - len(tile_sizes)

# Tile sizes for red, green, and blue tiles
tile_sizes = [2, 3, 4]
length = 50
print(count_ways(length, tile_sizes))",1151
118,"Using all of the digits $1$ through $9$ and concatenating them freely to form decimal integers, different sets can be formed. Interestingly with the set $\{2,5,47,89,631\}$, all of the elements belonging to it are prime.
How many distinct sets containing each of the digits one through nine exactly once contain only prime elements?

",44680,"from itertools import permutations

# Function to check if a number is prime
def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

# Generate all permutations of the digits 1 through 9
perms = [''.join(p) for p in permutations('123456789')]

# Function to split the string into all possible sets of prime numbers
def split_into_primes(s):
    for i in range(1, len(s)):
        for j in range(i+1, len(s)):
            for k in range(j+1, len(s)):
                for l in range(k+1, len(s)):
                    num1 = int(s[:i])
                    num2 = int(s[i:j])
                    num3 = int(s[j:k])
                    num4 = int(s[k:l])
                    num5 = int(s[l:])
                    if is_prime(num1) and is_prime(num2) and is_prime(num3) and is_prime(num4) and is_prime(num5):
                        return True
    return False

# Count the number of distinct sets containing each of the digits one through nine exactly once that contain only prime elements
count = 0
for perm in perms:
    if split_into_primes(perm):
        count += 1

print(count)",
119,"The number $512$ is interesting because it is equal to the sum of its digits raised to some power: $5 + 1 + 2 = 8$, and $8^3 = 512$. Another example of a number with this property is $614656 = 28^4$.
We shall define $a_n$ to be the $n$th term of this sequence and insist that a number must contain at least two digits to have a sum.
You are given that $a_2 = 512$ and $a_{10} = 614656$.
Find $a_{30}$.

",248155780267521,"def find_a_n(n):
    result = []
    for a in range(2, 100):  # Assuming the power is less than 100
        for b in range(2, 10**a):  # Assuming the number is less than 10 raised to the power of a
            if sum(int(digit) for digit in str(b)) == a and b == a**int(str(b)[0]):
                result.append(b)
                if len(result) == n:
                    return result[-1]
    return -1  # In case n is not found within the assumed range

# Find a_30
print(find_a_n(30))",
132,"A number consisting entirely of ones is called a repunit. We shall define $R(k)$ to be a repunit of length $k$.
For example, $R(10) = 1111111111 = 11 \times 41 \times 271 \times 9091$, and the sum of these prime factors is $9414$.
Find the sum of the first forty prime factors of $R(10^9)$.

",843296,"from sympy import primerange, isprime

def find_repunit_prime_factors(k):
    repunit = int('1' * k)
    primes = list(primerange(2, repunit))
    factors_sum = 0
    count = 0

    for prime in primes:
        if repunit % prime == 0:
            factors_sum += prime
            count += 1
            if count == 40:
                break

    return factors_sum

# Since the number R(10^9) is too large for practical computation,
# this code will not run as-is and is for demonstration purposes only.
sum_of_primes = find_repunit_prime_factors(10**9)
print(sum_of_primes)",
142,"Find the smallest $x + y + z$ with integers $x \gt y \gt z \gt 0$ such that $x + y$, $x - y$, $x + z$, $x - z$, $y + z$, $y - z$ are all perfect squares.
",1006193,"def is_square(n):
    return n == int(n**0.5)**2

def find_smallest_xyz():
    z = 1
    while True:
        z2 = z*z
        for y in range(z + 1, 2*z):
            yz = y + z
            if is_square(yz):
                yz2 = yz*yz
                for x in range(y + 1, yz2 // (2*y) + 1):
                    if is_square(x + y) and is_square(x - y) and is_square(x + z) and is_square(x - z):
                        return x + y + z
        z += 1

# Find and print the smallest x + y + z
print(find_smallest_xyz())",3754
146,"The smallest positive integer $n$ for which the numbers $n^2 + 1$, $n^2 + 3$, $n^2 + 7$, $n^2 + 9$, $n^2 + 13$, and $n^2 + 27$ are consecutive primes is $10$. The sum of all such integers $n$ below one-million is $1242490$.

What is the sum of all such integers $n$ below $150$ million?
",676333270,"def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

def check_consecutive_primes(n):
    primes = [n**2 + 1, n**2 + 3, n**2 + 7, n**2 + 9, n**2 + 13, n**2 + 27]
    return all(is_prime(p) for p in primes)

def sum_of_integers(limit):
    total_sum = 0
    for n in range(10, limit):
        if check_consecutive_primes(n):
            total_sum += n
    return total_sum

# Set the limit below 150 million
limit = 150_000_000
print(sum_of_integers(limit))",
160,"For any $N$, let $f(N)$ be the last five digits before the trailing zeroes in $N!$.
For example,

$9! = 362880$ so $f(9)=36288$
$10! = 3628800$ so $f(10)=36288$
$20! = 2432902008176640000$ so $f(20)=17664$
Find $f(1\,000\,000\,000\,000)$.
",16576,"def last_five_digits(n):
    result = 1
    for i in range(1, n + 1):
        result = result * i % 1000000  # Keep more than 5 digits to handle trailing zeroes
        while result % 10 == 0:  # Remove trailing zeroes
            result //= 10
    return f""{result:05d}""[-5:]  # Format to ensure 5 digits are returned

# Example usage:
# print(last_five_digits(1000000000000))",
164,"How many $20$ digit numbers $n$ (without any leading zero) exist such that no three consecutive digits of $n$ have a sum greater than $9$?
",378158756814587,"def count_numbers(length, sum_last_two, last_digit):
    if length == 1:
        return 1 if last_digit <= 9 else 0
    if (length, sum_last_two, last_digit) in memo:
        return memo[(length, sum_last_two, last_digit)]
    
    total_count = 0
    for digit in range(10):
        if sum_last_two + digit <= 9:
            total_count += count_numbers(length - 1, last_digit + digit, digit)
    
    memo[(length, sum_last_two, last_digit)] = total_count
    return total_count

memo = {}
total_20_digit_numbers = sum(count_numbers(20, 0, first_digit) for first_digit in range(1, 10))
print(total_20_digit_numbers)",378159000000000
172,"How many $18$-digit numbers $n$ (without leading zeros) are there such that no digit occurs more than three times in $n$?
",2.27E+17,"from itertools import product
from collections import Counter

# Function to check if no digit occurs more than three times
def is_valid(number):
    return all(count <= 3 for count in Counter(number).values())

# Generate all 18-digit numbers and filter based on the condition
valid_numbers = [''.join(p) for p in product('123456789', repeat=1) + product('0123456789', repeat=17) if is_valid(p)]

# Output the count of valid numbers
print(len(valid_numbers))",
173,"We shall define a square lamina to be a square outline with a square ""hole"" so that the shape possesses vertical and horizontal symmetry. For example, using exactly thirty-two square tiles we can form two different square laminae:


With one-hundred tiles, and not necessarily using all of the tiles at one time, it is possible to form forty-one different square laminae.
Using up to one million tiles how many different square laminae can be formed?
",1572729,"def count_laminae(tiles):
    count = 0
    for outer_side in range(3, tiles // 4 + 1):
        for inner_side in range(outer_side - 2, 0, -2):
            if outer_side * outer_side - inner_side * inner_side <= tiles:
                count += 1
            else:
                break
    return count

# Using up to one million tiles
print(count_laminae(1000000))",1572728
178,"Consider the number $45656$. 
It can be seen that each pair of consecutive digits of $45656$ has a difference of one.
A number for which every pair of consecutive digits has a difference of one is called a step number.
A pandigital number  contains every decimal digit from $0$ to $9$ at least once.

How many pandigital step numbers less than $10^{40}$ are there?

",126461847755,"def is_step(n):
    s = str(n)
    for i in range(len(s) - 1):
        if abs(int(s[i]) - int(s[i+1])) != 1:
            return False
    return True

def is_pandigital(n):
    return set(str(n)) == set(""0123456789"")

def count_pandigital_step_numbers(limit):
    count = 0
    for i in range(1023456789, limit):
        if is_step(i) and is_pandigital(i):
            count += 1
    return count

# Since the number is very large, we use a more efficient approach
# This is a placeholder for the actual efficient algorithm
# The efficient algorithm would likely involve dynamic programming
# to keep track of the step numbers and pandigital property

# Placeholder for the actual count
count = ""efficient_algorithm_placeholder""

print(count)",efficient_algorithm_placeholder
179,"Find the number of integers $1 \lt n \lt 10^7$, for which $n$ and $n + 1$ have the same number of positive divisors. For example, $14$ has the positive divisors $1, 2, 7, 14$ while $15$ has $1, 3, 5, 15$.
",986262,"def count_same_divisors(limit):
    def num_divisors(n):
        divisors = 0
        for i in range(1, int(n**0.5) + 1):
            if n % i == 0:
                divisors += 2 if i * i != n else 1
        return divisors

    count = 0
    prev_divisors = num_divisors(2)
    for n in range(3, limit):
        current_divisors = num_divisors(n)
        if current_divisors == prev_divisors:
            count += 1
        prev_divisors = num_divisors(n + 1)
    return count

# Set the limit as 10^7
limit = 10**7
print(count_same_divisors(limit))",
187,"A composite is a number containing at least two prime factors. For example, $15 = 3 \times 5$; $9 = 3 \times 3$; $12 = 2 \times 2 \times 3$.

There are ten composites below thirty containing precisely two, not necessarily distinct, prime factors:
$4, 6, 9, 10, 14, 15, 21, 22, 25, 26$.

How many composite integers, $n \lt 10^8$, have precisely two, not necessarily distinct, prime factors?
",17427258,"def count_composites(limit):
    primes = sieve(limit)
    count = 0
    for i in range(len(primes)):
        for j in range(i, len(primes)):
            if primes[i] * primes[j] < limit:
                count += 1
            else:
                break
    return count

def sieve(n):
    prime = [True for _ in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    primes = []
    for p in range(2, n):
        if prime[p]:
            primes.append(p)
    return primes

# Change the value of n to the desired limit, in this case, 10^8
n = 10**8
print(count_composites(n))",17427258
206,"Find the unique positive integer whose square has the form 1_2_3_4_5_6_7_8_9_0, where each “_” is a single digit.
",1389019170,"def find_special_number():
    # Start with the smallest number that, when squared, is close to the pattern.
    # The pattern suggests the number ends in 0, so the square root must end in 0.
    # We can start at 1010101010 and go up by increments of 10.
    num = 1010101010
    while True:
        square = str(num * num)
        # Check if the square matches the pattern 1_2_3_4_5_6_7_8_9_0
        if (square[0] == '1' and square[2] == '2' and square[4] == '3' and
            square[6] == '4' and square[8] == '5' and square[10] == '6' and
            square[12] == '7' and square[14] == '8' and square[16] == '9' and
            square[18] == '0'):
            return num
        num += 10

# Find and print the special number
special_number = find_special_number()
print(special_number)",1389019170
208,"A robot moves in a series of one-fifth circular arcs ($72^\circ$), with a free choice of a clockwise or an anticlockwise arc for each step, but no turning on the spot.

One of $70932$ possible closed paths of $25$ arcs starting northward is



Given that the robot starts facing North, how many journeys of $70$ arcs in length can it take that return it, after the final arc, to its starting position?
(Any arc may be traversed multiple times.) 


",3.32E+17,"# Python code to solve the robot arc problem

from itertools import product

def is_valid_path(path):
    # Starting direction is north (0: north, 1: east, 2: south, 3: west)
    direction = 0
    for move in path:
        if move == 'C':
            # Clockwise move
            direction = (direction - 1) % 4
        else:
            # Anticlockwise move
            direction = (direction + 1) % 4
    # Check if the robot returns to the starting direction (north)
    return direction == 0

def count_valid_paths(arc_length):
    # Generate all possible combinations of 'C' (clockwise) and 'A' (anticlockwise) moves
    all_paths = product('CA', repeat=arc_length)
    # Filter valid paths that return to the starting position
    valid_paths = filter(is_valid_path, all_paths)
    return len(list(valid_paths))

# Calculate the number of valid paths for 70 arcs
number_of_paths = count_valid_paths(70)
print(number_of_paths)",
211,"For a positive integer $n$, let $\sigma_2(n)$ be the sum of the squares of its divisors. For example,
$$\sigma_2(10) = 1 + 4 + 25 + 100 = 130.$$
Find the sum of all $n$, $0 \lt n \lt 64\,000\,000$ such that $\sigma_2(n)$ is a perfect square.
",1922364685,"from math import sqrt

def is_perfect_square(n):
    return int(sqrt(n)) ** 2 == n

def sigma_2(n):
    total = 0
    for i in range(1, int(sqrt(n)) + 1):
        if n % i == 0:
            total += i**2
            if i != n // i:
                total += (n // i)**2
    return total

def compute():
    LIMIT = 64000000
    result = 0
    for i in range(1, LIMIT):
        if is_perfect_square(sigma_2(i)):
            result += i
    return result

print(compute())",
222,"What is the length of the shortest pipe, of internal radius $\pu{50 mm}$, that can fully contain $21$ balls of radii $\pu{30 mm}, \pu{31 mm}, \dots, \pu{50 mm}$?

Give your answer in micrometres ($\pu{10^{-6} m}$) rounded to the nearest integer.
",1590933,"# Python code to calculate the length of the shortest pipe in micrometres

# Function to calculate the total length required
def calculate_length(balls_radii, pipe_radius):
    total_length = 0
    for radius in balls_radii:
        total_length += 2 * (pipe_radius - radius)
    return total_length

# Given data
balls_radii = [i for i in range(30, 51)]  # Radii from 30mm to 50mm
pipe_radius = 50  # Pipe internal radius in mm

# Calculate the length in mm and convert to micrometres
length_mm = calculate_length(balls_radii, pipe_radius)
length_micrometres = length_mm * 1000  # Convert mm to micrometres

# Round to the nearest integer
length_micrometres_rounded = round(length_micrometres)

# Output the result
print(length_micrometres_rounded)",420000
231,"The binomial coefficient $\displaystyle \binom {10} 3 = 120$.
$120 = 2^3 \times 3 \times 5 = 2 \times 2 \times 2 \times 3 \times 5$, and $2 + 2 + 2 + 3 + 5 = 14$.
So the sum of the terms in the prime factorisation of $\displaystyle \binom {10} 3$ is $14$.

Find the sum of the terms in the prime factorisation of $\displaystyle \binom {20\,000\,000} {15\,000\,000}$.

",7526965179680,"from math import factorial
from sympy import factorint

def prime_factors_sum(n, k):
    # Calculate binomial coefficient
    binom_coeff = factorial(n) // (factorial(k) * factorial(n - k))
    # Get prime factors and their powers
    factors = factorint(binom_coeff)
    # Calculate the sum of the terms in the prime factorization
    return sum(base * power for base, power in factors.items())

# Find the sum of the terms in the prime factorization of binom(20_000_000, 15_000_000)
result = prime_factors_sum(20_000_000, 15_000_000)
print(result)",
249,"Let $S = \{2, 3, 5, \dots, 4999\}$ be the set of prime numbers less than $5000$.
Find the number of subsets of $S$, the sum of whose elements is a prime number.
Enter the rightmost $16$ digits as your answer.
",9.27526E+15,"from sympy import primerange, isprime

# Generate the set of prime numbers less than 5000
primes = list(primerange(2, 5000))

# Function to calculate the power set of a list
def power_set(lst):
    result = [[]]
    for i in lst:
        new_subset = [subset + [i] for subset in result]
        result.extend(new_subset)
    return result

# Function to check if the sum of elements in a subset is prime
def is_prime_sum(subset):
    return isprime(sum(subset))

# Calculate the power set of primes
pset = power_set(primes)

# Count the number of subsets whose sum of elements is a prime number
prime_sum_subsets_count = sum(1 for subset in pset if is_prime_sum(subset))

# Output the rightmost 16 digits of the count
print(str(prime_sum_subsets_count)[-16:])",
250,"Find the number of non-empty subsets of $\{1^1, 2^2, 3^3,\dots, 250250^{250250}\}$, the sum of whose elements is divisible by $250$. Enter the rightmost $16$ digits as your answer.
",1.42548E+15,"MOD = 10**16

def power_mod(base, exponent, modulus):
    result = 1
    while exponent > 0:
        if exponent % 2 == 1:
            result = (result * base) % modulus
        base = (base * base) % modulus
        exponent //= 2
    return result

def count_subsets(divisor, max_exponent):
    count = [1] + [0] * divisor
    for i in range(1, max_exponent + 1):
        next_count = count[:]
        addend = power_mod(i, i, divisor)
        for j in range(divisor):
            next_count[(j + addend) % divisor] += count[j]
            next_count[(j + addend) % divisor] %= MOD
        count = next_count
    return (count[0] - 1) % MOD

print(count_subsets(250, 250250))",1.42548E+15
357,"
Consider the divisors of $30$: $1,2,3,5,6,10,15,30$.
It can be seen that for every divisor $d$ of $30$, $d + 30 / d$ is prime.


Find the sum of all positive integers $n$ not exceeding $100\,000\,000$such that for every divisor $d$ of $n$, $d + n / d$ is prime.


",1739023853137,"from sympy import isprime

def sum_of_special_numbers(limit):
    total_sum = 0
    for n in range(1, limit + 1):
        all_prime = True
        for d in range(1, int(n**0.5) + 1):
            if n % d == 0:
                if not (isprime(d + n // d) and isprime(n // d + d)):
                    all_prime = False
                    break
        if all_prime:
            total_sum += n
    return total_sum

# Set the limit to 100,000,000
limit = 100000000
print(sum_of_special_numbers(limit))",
500,"The number of divisors of $120$ is $16$.
In fact $120$ is the smallest number having $16$ divisors.


Find the smallest number with $2^{500500}$ divisors.
Give your answer modulo $500500507$.


",35407281,"def smallest_number_with_divisors(modulo):
    prime_numbers = []
    number = 1
    i = 2

    # Function to check for primality
    def is_prime(n):
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        j = 5
        while j * j <= n:
            if n % j == 0 or n % (j + 2) == 0:
                return False
            j += 6
        return True

    # Generating prime numbers and calculating the result
    while len(prime_numbers) < 500500:
        if is_prime(i):
            prime_numbers.append(i)
            number = (number * i) % modulo
        i += 1

    return number

# Call the function with the given modulo
print(smallest_number_with_divisors(500500507))",427102806